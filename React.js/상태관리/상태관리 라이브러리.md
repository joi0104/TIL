## 상태관리 라이브러리

### ContextAPI

- 리액트에서 공식적으로 만든 전역 데이터를 위한 API이다.
- contextAPI를 사용하기 위한 Context, 전역 값을 저장하고 이를 제공하는 Provider, context를 구독하는 Consumer로 이루어져있다.
- 실제로 context는 이러한 수단 일뿐, context내부에서 상태를 정의하고 이를 변경하는 것은 useState와 useReducer가 담당한다. ~~context 내부에서 상태를 정의하지 않으면 provider의 부모가 랜더링 될때마다 하위 컴포넌트들이 모두 리랜더링 되는 문제를 가진다~~
- 코드의 작성이 어렵지 않아 코드의 복잡도가 낮아지고 React에 내장되어 있다보니 외부 모듈에 의존하지 않아도 된다.
- 하지만 Redux와 달리 context에서 변경이 일어나면 의존하고 있는 컴포넌트들은 의존하고 있는 값이 아니더라도 무조건 리랜더링을 거친다. 따라서 철저히 관심사를 분리해서 무분별한 리랜더링을 방지해야 한다.

![](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c9cacbba-89f3-4e22-a3f0-72e9b3a36f7d/Untitled.png)

![](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/caa671f0-7fde-4939-bc28-ecde7468dec6/Untitled.png)

### Redux

- Flux 패턴에서 영감을 받아 을 적용한 전역 상태 라이브러리이다.
- 상태의 변경 발생을 알리는 Action/ 상태를 변경하는 Reducer/ 상태와 리듀서를 저장하고 있는 Store/크게 3가지로 이루어져있다.
- Flux 패턴과 다르게 리덕스는 하나의 스토어를 가지고 있으며 상태가 불변성을 가지며 순수함수인 리듀서를 통해서 상태가 변경된다. 또한 디스패처가 분리되어있지 않고 스토어에 내장되어 있다.
- 어플리케이션 상태/ 무엇이 일어나는지/ 어떻게 바꾸는지를 분리해서 개발해야하기 때문에 단방향흐름으로 안정적인 상태 운용이 가능하다.
- 하지만 그만큼 상태의 추가나 수정에 대해서 많은 부분을 건드려야 하기 때문에 코드의 복잡도가 심화되고 확장성이 떨어진다. 또한 `서버 캐시 상태` 를 저장한다면 한가지의 문제가 존재하는데, 언제 데이터를 불러와야하고 어디에 저장해야 하는가를 생각해야 하는 문제가 존재한다.

### Redux middleware

- redux는 리듀서와 액션을 통해 상태를 어떻게 변이시킬 것인지에 대해서만 관심이 있다. 상태를 변이시키기 위해 어떤 입력을 받고 어떤 처리를 통해 어떤 값으로 변이를 일으킬지 이러한 비지니스 로직에 대한 관심을 가지지 않는다.
- 이런 관심의 부재는 오롯이 컴포넌트가 부담하게 된다. 하지만 비지니스 로직이 커지고 복잡해질수록 컴포넌트의 역할이 방대해지며 본래의 역할을 벗어나게 된다. 이러한 컴포넌트의 부담을 덜어주기 위해 redux middleware가 나타나게 된다.

### Redux saga

- 기존의 Redux thuck와 같은 middleware 라이브러리는 하나의 액션이 여러개의 액션을 포함하고 있을 때, 혹은 여러개의 액션이 동시다발적으로 발생하였을 때 이 액션이 리듀서에게 던져지는 시점이 언제인지 그리고 정말 리듀서까지 잘 도달을 할 수 있을 지 등을 미리 예측하기 어려워진다. 즉, 하나의 액션으로 변경된 상태변화를 예측하기가 어려워진다는 것이다.
- Redux saga는 이러한 문제를 해결하여 제네레이터를 이용해 액션의 순수성을 보장하는 redux middleware 라이브러리이다.
- put, call 과 같이 액션을 dispatch 하고 함수를 호출하는 API 부터 takeEvery, takeLatest 와 같이 여러개의 액션에 대해서 다양하게 처리를 하는 API들이 존재한다.

### 출처

- [https://min9nim.vercel.app/2020-04-23-redux-saga/](https://min9nim.vercel.app/2020-04-23-redux-saga/)
