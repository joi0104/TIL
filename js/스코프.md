# 스코프


## 7.1 스코프와 존재

- 스코프는 실행 컨택스트에서 현재 보이고 접근할 수 있는 식별자의 영역을 말한다.

- 존재는 그 식별자가 메모리에 할당된 무언가를 가리키고 있다는 것을 말한다.

- 무언가가 더이상 존재하지 않는다고 해도 바로 메모리가 회수되지 않고 가비지 콜렉션에 이동한다.


## 7.2 정적 스코프와 동적 스코프

- 정적 스코프란 변수가 어떤 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있다는 뜻이다.

- 동적 스코프란 변수가 어떤 함수 스코프 안에 있는지 함수를 실행할 때 알 수 있다는 뜻이다.

- 자바스크립트는 정적 스코프를 따르며 함수 스코프, 블록 스코프에 적용이 된다. (이말은 뒤에가면 정확히 알 수 있다)


## 7.3 전역 스코프와 지역 스코프

- 스코프는 계층적인 트리 구조를 가진다.

- 부모 스코프의 변수와 자기 스코프의 변수에는 접근할 수 있으며, 이외의 스코프의 변수에는 접근할 수 없다.

- 전역 스코프란 프로그램을 시작할 때 암시적으로 주어지는 스코프로써 최상위 부모 스코프이다.

- 지역 스코프란 전역 스코프가 아닌 스코프를 지역 스코프라고 한다.

- 자바스크립트에서 지역 스코프는 함수 스코프와 블록 스코프가 존재한다.

- 전역 스코프를 남용하지 않고 의존적이지 않게 코드를 짜는 것이 중요하다.

  ```javascript
  let name = "jinyoung";
  let age = 24;
  
  function greet() {
      console.log(`Hello ${name}!`);
  }
  
  function getBirthYear() {
      return new Date().getFullYear() - age;
  }
  ```

  위 와 같은 코드는 두가지의 문제를 일으킨다. 한가지는 전역 변수인 name, age에 너무 의존적이며,  name과 age는 흔한이름 이므로 코드가 복잡해지다 보면 원하는 값이 아닌 다른 값을 불러올 수 있다.

  ```javascript
  function greet(user) {
      console.log(`Hello ${user.name}!`);
  }
  
  function getBirthYear(user) {
      return new Date().getFullYear() - user.age;
  }
  ```

  따라서 다음과 같이 문제를 해결할 수 있다. 매개변수를 추가해서 전역 스코프에 대한 의존성을 해결하였다.


## 7.4 함수 스코프

- 함수 스코프란 `function f() { }`에 의해서 생성되는 지역 스코프이다.

-  `const, let` 를 제외한 자바스크립트의 모든 변수들은 함수 스코프 변수이다.


## 7.5 블록 스코프

- 블록 스코프란 `{ }`에 의해서 생성되는 지역 스코프이다.

- ES6에서 새롭게 도입되었다.

- 자바스크립트의 `let`과 `const`은 블록 스코프 변수이다.

- 함수를 선언할 때는 중괄호를 사용해야 하므로 블록 스코프는 함수 스코프의 서브셋이다. (화살표 함수를 사용해서 암시적 반환을 하는게 아니라면)


## 7.6 스코프 체인과 변수 숨기기

- 스코프 체인이란 스코프의 계층적인 구조로 인해서 어떤 변수가 스코프에 있는지 확인하는 것이다.

- 변수 숨기기란, 같은 이름을 가진 변수를 선언하므로써 외부 스코프에 존재했던 변수를 숨기는 것을 말한다. 변수 섀도우라고도 한다.

- 현재 스코프 체인에 있는 모든 변수는 스코프에 있는 것이며, 숨겨지지 않았다면 접근할 수 있다.

```javascript
{
    let x = 'blue';
    console.log(x); //blue
    {
        let x = 'red';
        console.log(x); //red
    }
    console.log(x); //blue
}
```

 위 코드에서 내부 블록의 x는 외부 블록에서 정의한 x와 이름만 같은 뿐 다른 변수 이므로 외부 스코프의 x를 숨기는 효과가 있다. 
 
 여기에서 중요한 것은, 새 변수 x를 정의하는 순간 두 변수가 모두 스코프 안에 있으며 외부 스코프에 있는 변수에는 접근할 방법이 없다는 것이다.


## 7.7 클로저

- 클로저란 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것이다. 스코프를 함수 주변으로 좁히는 것이라고 할 수 있다.

- 스코프 안에서 함수를 정의하면 해당 스코프는 더 오래 유지가 된다.

- 또한 일반적으로는 접근할 수 없는 것에 접근할 수 있다는 효과도 있다.

  ```javascript
  let globalFunc;
  {
      let blockVar = 'a';
      globalFunc = function() {
          console.log(blockVar);
      }
  }
  globalFunc();
  ```


## 7.8 즉시 호출하는 함수 표현식

- 즉시 호출하는 함수 표현식(IIFE)이란 함수를 선언하고 즉시 실행하는 것이다.

  ```javascript
  (function() {
      // body
  })();
  ```

- 내부에 있는 것들이 자신만의 스코프를 가지며 안전하게 보호된다.

- 함수이므로 그 스코프 밖으로 무엇가를 내보낼 수 있다.

- ES6에서 블록 스코프 변수를 도입하면서 필요한 경우가 줄어들었지만 그래도 매우 널리 쓰인다.


## 7.9 호이스팅

- 호이스팅이란,  스코프의 가장 맨 앞으로 변수나 함수를 끌어올리는 것을 말한다.

- 변수는 함수 스코프 변수인 `var`변수만 해당한다.  이때, 호이스팅에 의해서 변수의 선언만 끌어올려지며 할당은 끌어올려지지 않는다.

- 함수도 함수 스코프를 따르므로 호이스팅에 의해서 스코프 맨위로 올려진다.


## 7.10 사각지대

- 사각지대란, `let`이나 ` const`로 선언하는 변수는 스코프 내에서 존재하지 않는다는 직관적 개념 나타낸 것이다.

- 스코프 안에서 변수의 사각지대는 변수가 선언되기 전의 코드이다.


## 7.11 스트릭트 모드

- 스트릭트 모드란 ES5에서 허용한 암시적 전역 변수를 허용하지 않는 모드를 말한다.

  > 암시적 전역 변수 : var 변수로 선언하는 것을 잊으면 자바스크립트는 전역 변수를 참조하려고 간주하고, 존재하지 않으면 스스로 만든다.

- 스트릭트 모드를 사용하려면 문자열 "use strict" 를 코드 한 행 맨앞에 쓰면 된다.

- 하나하나 전부 "user strict"를 쓰기 싫다면 코드 전체를 즉시 실행되는 함수 하나로 감싸면 된다.

  ```javascript
  (function() {
      'use strict';
      // body
  })();
  ```

