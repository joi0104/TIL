## Proxy 패턴

### 정의

> 대리자 역할을 하는 객체를 두어 다른 객체에 대한 접근을 제어하는 패턴

### 동기

- 어떤 객체를 사용할 수 있을 때 까지 객체의 생성과 초기화에 드는 비용을 물지 않기 하기 위해 객체에 대한 접근을 제어해야하는 경우가 있다.
- 예를 들어 생성의 비용이 비싼 그래픽 객체를 넣을 수 있는 문서 편집기를 생각해보자.
- 불러온 문서를 읽고 그래픽 객체를 생성하여 불러온 문서의 내용을 객체에 넣어야 하는 작업이 존재한다.

<br />

- 이때 문서를 읽어오는 것은 그래픽 객체가 생성되고 안되고와 상관없이 이뤄져야 한다.
- 이러한 이유로 생성과 관리가 어려운 객체라면 `꼭 필요할 때만 이 객체를 생성한다` 라는 방법이 제기 되었다.
- 문서를 불러오자마자 바로 그래픽 객체를 생성하는 것이 아니라, 문서를 `draw`하는 등 실제로 사용할 때 그래픽 객체를 생성하는 방식인 것이다.

<br />

- 하지만 이때, **객체를 생성할 때 어떤 내용을 넣어야하는 지 어떻게 기억하고 있어야 할까?**
- 또 **꼭 필요할 때만 이 객체를 생성한다 다는 사실을 감추면서 문서 편집기의 구현을 복잡하게 만들지 않을 방법`이 없을까?**
  <br />

- `Proxy 패턴`을 통해 객체에 넣어야 할 내용, 제약사항들을 기억하고 있고꼭 필요할 때만 객체를 생성하므로써 객체의 생성 단계를 감출 수 있다.

### 활용성

1. `원격지 프록시` : 서로 다른 주소 공간에 존재하는 객체를 가리키는 프록시를 둘 수 있다.
2. `가상 프록시` : 요청이 있을때만 필요한 고비용 객체를 생성하는 프록시를 둘 수 있다.
3. `보호용 프록시` : 원래 객체에 대한 실제 접근을 제어하여 권한에 따른 제어를 하는 프록시를 둘 수 있다.
4. `스마트 참조자` : 원시 포인터를 대체하는 프록시를 둘 수 있다. 참조 횟수를 저장하거나 맨 처음 참조시 메모리로 객체를 옮기거나 객체에 접근하기 전에 다른 접근을 막기위한 lock 등등의 작업을 둘 수 있다.

### 구조

![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/400px-Proxy_pattern_diagram.svg.png)

- `Proxy`
  - 실제로 참조할 대상 `RealSubject` 에 대한 참조자를 관리한다.
  - `Subject`와 동일한 인터페이스를 제공하여 실제 대상을 대체할 수 있어야 한다.
  - 실제 대상에 대한 접근을 제어하고 실제 대성의 생성과 삭제를 책임진다.
- `Subject` : `RealSubject` 와 `Proxy`에 공통적인 인터페이스를 정의하여 `RealSubject` 가 요청되는 곳에 `Proxy`를 사용할 수 있게 한다.
- `RealSubject` : `Proxy`가 참조하는 실제 객체이다.

### 협력

- `Client`는 오직 `Subject`의 인터페이스를 통해서만 대상에 접근하고 조작한다.
- `Proxy` 객체는 자신이 받은 요청을 `RealSubject`에 전달한다.

### 결과

- `Proxy 패턴`은 어떤 객체에 접근할 때 추가적인 간접화 통로를 제공한다!
  - `원격지 프록시`에서는 다른 주소 공간에 존재하는 객체를 숨길 수 있다.
  - `가상 프록시`에서는 요구에 따라 객체 생성을 최적화 할 수 있다.
  - `보호용 프록시` 및 `스마트 참조자`는 객체가 접근할 때마다 추가 관리를 수행할 수 있다.
- `기록 시점 복사` 최적화를 수행 할 수 있다. 비용 이 큰 객체를 복사할 때, 복사 절차를 미룸으로써 사본이 수정될 때만 실제 복사 비용을 물게 만들 수 있다.

### 관련 패턴

- `Adapter 패턴`은 자신이 개조할 객체와 다른 인터페이스를 제공한다. 반면에, `Proxy 패턴`은 자신이 상대하는 대상과 동일한 인터페이스를 제공한다.
- `Decorater 패턴`은 하나 이상의 서비스를 추가하기 위한 패턴이다. 반면에, `Proxy 패턴`은 객체에 대한 접근을 제어하기 위한 패턴이다.
