## Chain of Responsibility 패턴 (책임 연쇄 패턴)

### 정의

> 하나의 요청에 대한 처리가 반드시 한 객체에서만 되지 않고 여러 객체에게 처리 기회를 주는 패턴

### 동기

- 문맥 감지 도움말 기능을 생각해보자. 사용자가 정보를 선택하면 그 부분에 대한 도움말 정보를 얻을 수 있다. 만약, 선택한 주체에 대한 구체적인 도움말이 없다면 도움말 시스템은 적어도 응용프로그램이 정의한 일반적인 도움말이라도 제공해야 한다.

- 이때, `도움말을 제공할 객체`가 `도움말 요청을 보내는 객체`에게 알려져있지 않아야 한다. `도움말 요청을 보내는 객체`가 `도움말을 제공할 객체들`의 참조자를 가지고 있고 참조자를 통해 직접적으로 `도움말을 제공할 객체들`에게 요청을 보낸다면 이는 관심사의 분리가 잘 되어있지 않은 경우이다.

- `책임 연쇄 패턴`을 사용하면, 메시지 송신측과 수신측을 분리하여 메시지를 처리하는 객체를 은닉시킬 수 있다. 송신하는 측이 자신이 아는 주체에게 처리를 요청하면 이를 수신한 객체가 자신과 연결된 고리를 따라서 요청을 전달하고 어느 한 객체가 실제 상황에 적합하다고 판단되면 자신에게 정의된 서비스를 제공할 수 있다.

### 활용성

- 하나 이상의 객체가 요청을 처리해야 하고, 그 요청 처리자 중 어떤 것이 선행자(실제로 요청을 처리하는 자)인지 모를 떄

- 메시지를 받을 객체를 명시하지 않은 채 여러 객체 중 하나에게 처리를 요청하고 싶을 때

- 요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때

### 구조

![](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99BB50475ADDDB0818)

- `Handler` : 요청을 처리하는 인터페이스를 정의하고, 연결 고리에 연결되 다음 객체(후속 처리자)에게 메시지를 보내는 객체

- `ConcreteHandler` : 자신이 처리할 행동이 있으면 처리하는 객체

### 협력

- `Handler`는 `Client` 로 부터 온 처리의 요청을 받아 실제로 요청을 받을 책임이 있는 `ConcreteHandler`객체를 만날 때까지 정의된 연결고리를 따라 계속 전달한다.

### 결과

1. **객체 간의 행동적 결합도가 적어진다.** 단지 요청을 보내는 객체는 이 메시지가 적절하게 처리될 것만 알게되고 메시지를 보내는 측이나 받는 측 서로를 모르고 연결된 객체들 조차도 서로를 모르게 된다.

2. **객체에게 책임을 할당하는 데 유연성을 높일 수 있다.** 객체의 책임을 여러 객체에 분산시킬 수 있으므로 런타임에 책임을 변경하거나 확장할 수 있다.

3. **메시지 수신이 보장되지 않는다.** 어떤 객체가 요청에 대한 처리를 담당한다는 것을 명시하지 않으므로 요청이 처리된다는 보장이 없다. 만약 연결고리가 잘 정의되지 않았다면 요청이 버려질수도 있다.
