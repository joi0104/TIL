## 7장 스코프



### 스코프와 존재

- 스코프는 실행 컨택스트에서 현재 보이고 접근할 수 있는 식별자의 영역을 말한다.

- 존재는 그 식별자가 메모리에 할당된 무언가를 가리키고 있다는 것을 말한다.

- 무언가가 더이상 존재하지 않는다고 해도 바로 메모리가 회수되지 않고 가비지 콜렉션에 이동한다.

  

### 정적 스코프와 동적 스코프

- 정적 스코프란 변수가 어떤 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있다는 뜻이다.

- 동적 스코프란 변수가 어떤 함수 스코프 안에 있는지 함수를 실행할 때 알 수 있다는 뜻이다.

- 자바스크립트는 정적 스코프를 따르며 함수 스코프, 블록 스코프에 적용이 된다. (이말은 뒤에가면 정확히 알 수 있다)

  

### 전역 스코프와 지역 스코프

- 스코프는 계층적인 트리 구조를 가진다.
- 부모 스코프의 변수와 자기 스코프의 변수에는 접근할 수 있으며, 이외의 스코프의 변수에는 접근할 수 없다.
- 전역 스코프란 프로그램을 시작할 때 암시적으로 주어지는 스코프로써 최상위 부모 스코프이다.
- 지역 스코프란 전역 스코프가 아닌 스코프를 지역 스코프라고 한다.
- 자바스크립트에서 지역 스코프는 함수 스코프와 블록 스코프가 존재한다.
- 전역 스코프를 남용하지 않고 의존적이지 않게 코드를 짜는 것이 중요하다.

```javascript
let name = "jinyoung";
let age = 24;

function greet() {
    console.log(`Hello ${name}!`);
}

function getBirthYear() {
    return new Date().getFullYear() - age;
}
```

위 와 같은 코드는 두가지의 문제를 일으킨다. 한가지는 전역 변수인 name, age에 너무 의존적이며,  name과 age는 흔한이름 이므로 코드가 복잡해지다 보면 원하는 값이 아닌 다른 값을 불러올 수 있다.

```javascript
function greet(user) {
    console.log(`Hello ${user.name}!`);
}

function getBirthYear(user) {
    return new Date().getFullYear() - user.age;
}
```

따라서 다음과 같이 문제를 해결할 수 있다. 매개변수를 추가해서 전역 스코프에 대한 의존성을 해결하였다.



### 함수 스코프

- 함수 스코프란 `function f() { }`에 의해서 생성되는 지역 스코프이다.

- `var` 로 선언한 변수나 함수들은 함수 스코프 변수이다.

  

### 블록 스코프

- 블록 스코프란 `{ }`에 의해서 생성되는 지역 스코프이다.

- ES6에서 새롭게 도입되었다.

-  `cosnt, let` 로 선언한 변수들은 블록 스코프 변수이다.

- 함수를 선언할 때는 중괄호를 사용해야 하므로 블록 스코프는 함수 스코프의 서브셋이다. (화살표 함수를 사용해서 암시적 반환을 하는게 아니라면)



### 스코프 체인과 변수 숨기기

- 스코프 체인이란 스코프의 계층적인 구조로 인해서 어떤 변수가 스코프에 있는지 확인하는 것이다.

- 변수 숨기기란, 같은 이름을 가진 변수를 선언하므로써 외부 스코프에 존재했던 변수를 숨기는 것을 말한다. 변수 섀도우라고도 한다.

- 현재 스코프 체인에 있는 모든 변수는 스코프에 있는 것이며, 숨겨지지 않았다면 접근할 수 있다.

```javascript
{
    let x = 'blue';
    console.log(x); //blue
    {
        let x = 'red';
        console.log(x); //red
    }
    console.log(x); //blue
}
```

 위 코드에서 내부 블록의 x는 외부 블록에서 정의한 x와 이름만 같은 뿐 다른 변수 이므로 외부 스코프의 x를 숨기는 효과가 있다. 

 여기에서 중요한 것은, 새 변수 x를 정의하는 순간 두 변수가 모두 스코프 안에 있으며 외부 스코프에 있는 변수에는 접근할 방법이 없다는 것이다.



### 클로저

- 클로저란 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것이다. 스코프를 함수 주변으로 좁히는 것이라고 할 수 있다.
- 스코프 안에서 함수를 정의하면 해당 스코프는 더 오래 유지가 된다.
- 또한 일반적으로는 접근할 수 없는 것에 접근할 수 있다는 효과도 있다.

```javascript
let globalFunc;
{
    let blockVar = 'a';
    globalFunc = function() {
        console.log(blockVar);
    }
}
globalFunc();
```



### 즉시 호출하는 함수 표현식 IIFE

- 즉시 호출하는 함수 표현식(IIFE)이란 함수를 선언하고 즉시 실행하는 것이다.

```javascript
(function() {
    // body
})();
```

- 내부에 있는 것들이 자신만의 스코프를 가지며 안전하게 보호된다.
- 함수이므로 그 스코프 밖으로 무엇가를 내보낼 수 있다.
- ES6에서 블록 스코프 변수를 도입하면서 필요한 경우가 줄어들었지만 그래도 매우 널리 쓰인다.

```js
const f = (function() {
	const count = 0;
	return function(){
		return `I have been called ${++count} time(s)`;
	}
})();

f(); //I have been called 1 time(s)
f(); //I have been called 2 time(s)
f(); //I have been called 3 time(s)
```



### 호이스팅과 사각지대

- 좋은 포스팅 글로 대체한다. [let 과 const는 호이스팅이 될까?](https://medium.com/korbit-engineering/let과-const는-호이스팅-될까-72fcf2fac365)




### 스트릭트 모드

- 스트릭트 모드란 ES5에서 허용한 암시적 전역 변수를 허용하지 않는 모드를 말한다.

  > 암시적 전역 변수 : var 변수로 선언하는 것을 잊으면 자바스크립트는 전역 변수를 참조하려고 간주하고, 존재하지 않으면 스스로 만든다.

- 스트릭트 모드를 사용하려면 문자열 "use strict" 를 코드 한 행 맨앞에 쓰면 된다.

- 하나하나 전부 "user strict"를 쓰기 싫다면 코드 전체를 즉시 실행되는 함수 하나로 감싸면 된다.

```javascript
(function() {
    'use strict';
    // body
})();
```

