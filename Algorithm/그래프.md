## 그래프

### 정의

- 자료구조의 일종
- 정점 `Node/Vertex` , 간선 `Edge` 으로 이루어져 있으며 `G=(V,E)` 로 나타낸다.

### 용어정리

- `경로`: 정점 A에서 정점 B까지의 이동하는 경로
- `사이클`: 경로의 시작지점과 끝지점이 같은 경로
- `단순 경로/사이클`: 같은 정점을 두 번이상 방문하지 않은 경로/사이클. 특별한 말이 없으면, 일반적으로 경로/사이클은 단순 경로/사이클을 말한다.
- `단방향 그래프`: 간선에 방향이 존재한다. `A->B` 는 `B->A` 를 나타내지 않는다.
- `양방향 그래프`: 간선에 방향이 존재하지 않는다. `A->B` 는 `B->A` 를 나타낸다.
- `루프`: 간선의 양 끝점이 같은 경우
- `가중치`: 간선에 주어진 비용
- `차수`: 정점과 연결되어 있는 간선의 개수. 방향 그래프의 경우에는 in-degree, out-degree로 나누어 차수를 계산한다.

### 그래프의 표현

- `인접 행렬`, `인접 그래프`, `간선 그래프`로 표현하는 방법이 존재한다.

### 인접 행렬

![image](https://user-images.githubusercontent.com/28296417/125164908-91786b00-e1cf-11eb-9322-88ea9ec14d46.png)

- 정점의 개수를 `V` 라고 했을 때, `V X V` 크키의 이차원 배열을 이용해서 그래프를 표현하는 방법
- `A[i][j]= 1(i->j 간선이 있을 때). 0(없을 때)`
- 가중치 그래프인 경우, `A[i][j]= w(i->j 간선이 있을 때). 0(없을 때)`
- 양방향 그래프인 경우 인접 행렬은 전치 행렬이다.
- 공간 복잡도의 경우 `O(V^2)` 이다.

### 인접 리스트

![image](https://user-images.githubusercontent.com/28296417/125164967-db615100-e1cf-11eb-9e48-af63e7ff1023.png)

- 각 정점에 인접한 정점들을 리스트에 저장해서 그래프를 표현하는 방법
- `A[i] = [j,k] (i->j i->k 간선이 있을 때)`
- 가중치 그래프인 경우, `A[i] = [[j,w], [k,w]] (i->j i->k 간선이 있을 때)`
- 공간 복잡도의 경우 `O(E)` 이다.

### 간선 리스트

![image](https://user-images.githubusercontent.com/28296417/125165005-faf87980-e1cf-11eb-8098-87cc05910fa1.png)

- 두 정점을 연결한 간선들을 리스트에 순차적으로 저장해서 그래프를 표현하는 방법
- `E[idx] = [i,j] (i->j 간선이 있을 때)`. i와 j가 오름차순이 되도록 저장한다.
- 정점 `i` 와 연결된 간선의 위치 `idx`는 아래 코드로 만든 `cnt ` 배열의 `cnt[i-1]` 부터 `cnt[i]-1` 까지이다.

```python
for i in range(v): cnt[e[i][0]] += 1
for i in range(1,v): cnt[i] = cnt[i-1] + cnt[i]
```

### DFS

- 깊이 우선 탐색
- 스택을 이용해서 최대한 깊이 내려가고 갈 수 없으면 옆으로 돌아가는 알고리즘
- 재귀호출을 이용하여 구현할 수 있다.

```python
#인접 행렬을 이용한 구현
def dfs(x):
  visit[x] = true
  for i in range(1,n+1):
    if a[x][i] and not visit[i]: dfs(i)

#인접 리스트를 이용한 구현
def dfs(x):
  visit[x] = true
  for i in range(len(a[x])):
    y = a[x][i]
    if not visit[y]: dfs(y)
```

### BFS

- 너비 우선 탐색
- 큐를 이용해서 최대한 넓게 이동한다음 더이상 갈 수 없을 때 아래로 이동하는 알고리즘
- 정점을 방문할때마다 갈 수 있는 정점을 큐에 넣어야 하며, 넣을 때 방문했다고 체크해야 한다.

```python
#인접 행렬을 이용한 구현
q = deque([1])
visit = [0,1]
while q:
  x = q.popleft()
  for i in range(1,n+1):
    if a[x][i] and not visit[i]:
      visit[i] = true
      q.append(i)

#인접 리스트를 이용한 구현
q = deque([1])
visit = [0,1]
while q:
  x = q.popleft()
  for i in range(len(a[x])):
    y = a[x][i]
    if not visit[y]:
      visit[y] = true
      q.append(y)
```

### 각각 어떨때 써야할까?

- 모든 정점을 방문해야 할 때는 두가지 방법은 어느 것을 사용해도 상관없다.
- 경로의 특징을 저장해둬야 할 때는 DFS를 사용해야 한다.
- 최단거리를 구해야 할 때는 BFS를 사용해야 한다. (최단거리, 최소경로를 추후에 자세히)
- 검색 대상 그래프가 정말 크다면 DFS, 크지 않고 검색 시작 지점으로부터 원하는 대상이 멀지 않다면 BFS를 고려한다.

### 연결요소

![image](https://user-images.githubusercontent.com/28296417/125165015-0a77c280-e1d0-11eb-8056-e251d769078b.png)

- 다음 그림과 같이 서로 연결되어 있지 않은 각각의 그래프들을 연결 요소라고 한다.
- 연결 요소에 속한 모든 정점은 서로를 연결하는 경로가 있어야 한다.
- 또, 다른 연결 요소에 속한 정점과 연결하는 경로가 있으면 안된다.
- 연결요소를 구하는 것은 DFS나 BFS탐색을 이용해서 구할 수 있다.

### 이분 그래프

![image](https://user-images.githubusercontent.com/28296417/125165031-18c5de80-e1d0-11eb-8b77-44aa00066a10.png)

- 다음 그림과 같이 A와 B로나눌 수 있는 그래프를 이분 그래프라고 한다.
- A에 포함되어 있는 정점끼리 연결된 간선이 없다.
- B에 포함되어 있는 정점끼리 연결된 간선이 없다.
- 모든 간선의 한 끝점은 A, 다른 끝점은 B가 된다.
- 이분 그래프 여부는 DFS나 BFS탐색을 이용해서 구할 수 있다.
